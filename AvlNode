package oop.ex4.data_structures;

import sun.reflect.generics.tree.Tree;

public class AvlNode implements oop.ex4.data_structures.TreeNode {

    private static final int LEFT_SUB_HEIGHT = 0;
    private static final int RIGHT_SUB_HEIGHT = 1;

    private int data;
    private AvlNode parent;
    private AvlNode rightChild;
    private AvlNode leftChild;

    /**
     * A constructor for the AvlNode class. This constructor should only be used for the root.
     * @param setData the value to be set as the root's data.
     */
    public AvlNode(int setData){
        data = setData;
        parent = null;
        rightChild = null;
        leftChild = null;
    }

    /**
     * A constructor for the AvlNode class. This constructor should be used for the nodes other than the root.
     * @param setData the value to be set as the node's data.
     * @param setParent the node that is this node's parent.
     */
    public AvlNode(int setData, AvlNode setParent){
        data = setData;
        parent = setParent;
        rightChild = null;
        leftChild = null;
    }

    @Override
    public void setRightChild(TreeNode newRightChild){
        if (newRightChild != null) {
            rightChild = (AvlNode) newRightChild;
            rightChild.setParent(this);
        }
    }

    @Override
    public void setLeftChild(TreeNode newLeftChild){
        if (newLeftChild != null) {
            leftChild = (AvlNode) newLeftChild;
            leftChild.setParent(this);
        }
    }

    @Override
    public void setParent(TreeNode newParent){
        parent = (AvlNode) newParent;
    }

    @Override
    public AvlNode getParent() {
        return parent;
    }

    @Override
    public AvlNode getRightChild(){
        return rightChild;
    }

    @Override
    public AvlNode getLeftChild(){
        return leftChild;
    }

    @Override
    public void setData(int newData){
        data = newData;
    }

    @Override
    public int getData(){
        return data;
    }

    /**
     * Calculates the node's balance by measuring the difference in height of its two subtrees.
     * @return the value of the node's balance.
     */
    public int findNodeBalance(){
        int[] subHeights = findSubHeights();
        return (subHeights[LEFT_SUB_HEIGHT] - subHeights[RIGHT_SUB_HEIGHT]);
    }

    /**
     * Calculates the height of both the node's subtrees.
     * @return an array where the first value is the left subtree's height, and the second is the right's.
     */
    public int[] findSubHeights(){
        int[] subHeightArr = new int[2];
        if(this.getLeftChild() != null){
            subHeightArr[LEFT_SUB_HEIGHT] = this.getLeftChild().getNodeHeight() + 1;
        }
        if(this.getRightChild() != null) {
            subHeightArr[RIGHT_SUB_HEIGHT] = this.getRightChild().getNodeHeight() + 1;
        }
        return subHeightArr;
    }

    /**
     * @return the node's height.
     */
    public int getNodeHeight(){
        int[] subHeights = findSubHeights();
        return Math.max(subHeights[LEFT_SUB_HEIGHT], subHeights[RIGHT_SUB_HEIGHT]);
    }


}
