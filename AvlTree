package oop.ex4.data_structures;

import java.util.Iterator;

public class AvlTree extends BinarySearchTree {

    AvlNode root;

    /**
     * The default constructor for the AvlTree class
     */
    public AvlTree(){
        root = null;
    }

    /**
     * A constructor that takes an array of integers and initializes a new AvlTree containing the elements in
     * the array
     * @param data An array of integers to be added to the AVL Tree
     */
    public AvlTree(int[] data){
        if(data != null) {
            for (int newValue : data) {
                add(newValue);
            }
        }
        else{
            root = null;
        }
    }

    /**
     * A constructor that takes an existing AvlTree and creates a deep copy in a new AvlTree
     * @param tree the AvlTree to be deep-copied
     */
    public AvlTree(AvlTree tree){
        if(tree == null){
            root = null;
        }
        else{
            Iterator<Integer> treeIter= tree.iterator();
            AvlTree copyTree = new AvlTree();
            while(treeIter.hasNext()){
                copyTree.add(treeIter.next());
            }
        }
    }


    TreeNode getRoot(){
        return this.root;
    }

    /**
     * Take an integer and add it to the Avl tree
     * @param newValue the integer value to be added
     * @return True if the value was added successfully, false otherwise
     */
    public boolean add(int newValue) {
        System.out.println("CURRENT STRUCTURE");
        AvlNode current = root;
        while(current != null){
            System.out.println(current.getData());
            if(current.leftChild != null) {
                System.out.println("Left child: " + current.leftChild.getData() + "Parent " + current
                        .leftChild.getParent().getData());
                if(current.leftChild.leftChild != null)
                    System.out.println("Left left: " + current.leftChild.leftChild.getData() + "Parent: " +
                            current
                            .leftChild.leftChild.getParent().getData());
                if(current.leftChild.rightChild != null)
                    System.out.println("Left Right: " + current.leftChild.rightChild.getData() + "Parent: " +
                            current.leftChild.rightChild.getParent().getData());
            }

            current = current.rightChild;
        }

        System.out.println("ADDING " + newValue);

        if (contains(newValue) == NEGATIVE_CONTAINS_RESULT) {
            if (root == null) {
                root = new AvlNode(newValue);
            }
            else {
                AvlNode addedNode = addNode(root, root, newValue);
                rebalanceNode(addedNode, newValue);
            }
            return true;
        }
        else{
            return false;
        }
    }

    private AvlNode addNode(AvlNode node, AvlNode parent, int addValue){
        if(node == null){
            node = new AvlNode(addValue, parent);
            parent.setChild(node);
            return node;
        }
        else if(node.getData() > addValue){
            //node.setNodeHeight();
            node.increaseHeight();
            return(addNode(node.getLeftChild(), node, addValue));
        }
        else{
            //node.setNodeHeight();
            node.increaseHeight();
            return(addNode(node.getRightChild(), node, addValue));
        }
    }

    private void rebalanceNode(AvlNode node, int addValue){
        boolean print = (node.getData() == 0);
        int balance = node.findNodeBalance();
        if(print) System.out.println(balance + "root balance");
        // Left subtree is bigger.
        if(balance > 1){
            if(addValue < node.getLeftChild().getData()){
                rotateLeft(node);
            }
            else if(addValue > node.getLeftChild().getData()){
                rotateLeft(node.getLeftChild());
                rotateRight(node);
            }
        }
        // Right subtree is bigger.
        else if(balance < -1){
            if (print) System.out.println("attempting rotate on root");
            if(addValue > node.getRightChild().getData()){
                rotateRight(node);
            }
            else if(addValue < node.getRightChild().getData()){
                rotateRight(node.getRightChild());
                rotateLeft(node);
            }
        }
        if(node.getParent() != null){ // If we haven't reached the root.
            rebalanceNode(node.getParent(), addValue);
        }
    }

    /**
     * Take an integer and attempt to delete it from the Avl tree
     * @param toDelete the value to be deleted
     * @return True if the value is found and deleted successfully, false otherwise.
     */
    public boolean delete(int toDelete){
        if(contains(toDelete) != NEGATIVE_CONTAINS_RESULT){
            if(root.getData() == toDelete){
                AvlNode deleted = deleteNode(root);
                rebalanceNode(deleted, toDelete);
            }
            else {
                AvlNode deleted = findDeleteNode(root, toDelete);
                rebalanceNode(deleted, toDelete);
            }
            return true;
        }
        else{
            return false;
        }
    }

    private AvlNode findDeleteNode(AvlNode targetNode, int toDelete){
        if(targetNode.getData() == toDelete){
            return(deleteNode(targetNode));
        }
        else if(targetNode.getData() > toDelete){
            targetNode.setNodeHeight();
            return(findDeleteNode(targetNode.getLeftChild(), toDelete));
        }
        else{
            targetNode.setNodeHeight();
            return(findDeleteNode(targetNode.getRightChild(), toDelete));
        }
    }

    private AvlNode deleteNode(AvlNode targetNode){
        AvlNode targetParent = targetNode.getParent();
        AvlNode leftChildOfTarget = targetNode.getLeftChild();
        AvlNode rightChildOfTarget = targetNode.getRightChild();
        boolean leftNull = (leftChildOfTarget == null);
        boolean rightNull = (rightChildOfTarget == null);
        int targetValue = targetNode.getData();

        // Check which children target has, if any
        if(leftNull){
            if(rightNull){ // Target has no children
                targetNode = null;
                return targetParent;
            }
            else { // Target only has right child
                targetNode = rightChildOfTarget;
                targetNode.setParent(targetParent);
            }
        }
        else if(rightNull){ // Target only has left child
            targetNode = leftChildOfTarget;
            targetNode.setParent(targetParent);
        }
        else { // Target has two children
            Iterator<Integer> treeIter = this.iterator();
            int current = targetValue - 1;
            while (current != targetValue) {
                current = treeIter.next();
            }
            int nextValue = treeIter.next();
            delete(nextValue);
            targetNode.setData(nextValue);
        }

        return targetNode;
    }

    /**
     * Take an integer representing the height of an AvlTree and return the minimum number of nodes
     * possible in an AvlTree of that height.
     * @param h the height of an AvlTree
     * @return the minimum size of an AvlTree
     */
    public static int findMinNodes(int h){
        //Since the minimum size of the avl tree can be expressed as a recursive function, we can use the
        // fibonacci series to find it for height h, using (1 + sqrt(5)/2) as an approximation of the
        // golden ratio
        return (int)((((Math.pow(((1 + Math.sqrt(5))/2) , (h + 3))) - (Math.pow(((1 - Math.sqrt(5))/2),(h +
                3))))/ (Math.sqrt(5))) -1);
    }

    /**
     * Take an integer representing the height of an AvlTree and return the maximum number of nodes
     * possible in an AvlTree of that height
     * @param h the height of an AvlTree
     * @return the maximum size of an AvlTree
     */
    public static int findMaxNodes(int h){
        return (int)Math.pow(2, h+1) - 1;
    }

    private void rotateLeft(AvlNode rotateRoot){
        System.out.println("rotate left on " + rotateRoot.getData());
        boolean printzero = (rotateRoot.getData() == 0);
        if(printzero) System.out.println(rotateRoot.findNodeBalance() + " zero balance");
        if (rotateRoot.getLeftChild() != null) {
            //Set new references
            AvlNode newRoot = rotateRoot.getLeftChild(); // The left child is being pulled up.
            AvlNode newRightChildOfRoot = newRoot.getRightChild();
            AvlNode newRootParent = rotateRoot.getParent();

            //Rotate root
            newRoot.setChild(rotateRoot);
            rotateRoot.setChild(newRightChildOfRoot);
            if (newRootParent == null){
                newRoot.setParent(null);
                root = newRoot;
            }
            else newRootParent.setChild(newRoot);

            //Adjust heights
            newRoot.setNodeHeight();
            rotateRoot.setNodeHeight();
        }
    }


    private void rotateRight(AvlNode rotateRoot){
        System.out.println("rotate right on" + rotateRoot.getData());
        if (rotateRoot.getRightChild() != null){
            //Set new references
            AvlNode newRoot = rotateRoot.getRightChild();
            AvlNode newLeftChildOfRoot = newRoot.getLeftChild();
            AvlNode newRootParent = rotateRoot.getParent();

            //Rotate root
            newRoot.setChild(rotateRoot);
            System.out.println(rotateRoot.getData() + " asks " + rotateRoot.getParent().getData() + "Are " +
                            "you my mommy?");
            rotateRoot.setChild(newLeftChildOfRoot);
            if (newRootParent == null){
                newRoot.setParent(null);
                System.out.println("here?");
                root = newRoot;
            }
            else newRootParent.setChild(newRoot);

            //Adjust heights
            rotateRoot.setNodeHeight();
            newRoot.setNodeHeight();
        }
    }

//    public void printNode(AvlNode node){
//        System.out.println(node.getData());
//    }
//
//    public void printTree(AvlNode node){
//        if(node.rightChild != null)
//            printTree(true,"", node.rightChild);
//        printNode(node);
//        if(node.leftChild != null)
//            printTree(false,"", node.leftChild);
//    }
//
//    public void printTree(boolean isRight, String indent, AvlNode node){
//        AvlNode rightNode = null;
//        if(node.getRightChild() != null)
//            rightNode = node.getRightChild();
//        if (rightNode != null) {
//            printTree(true, indent + (isRight ? "        " : " |      "), rightNode);
//        }
//        System.out.print(indent);
//        if (isRight) System.out.print(" /");
//        else System.out.print(" \\");
//        System.out.print("----- ");
//        printNode(node);
//        AvlNode leftNode = node.getLeftChild();
//        if (leftNode != null) {
//            printTree(false, indent + (isRight ? " |      " : "        "), leftNode);
//        }
//    }

    public static void main(java.lang.String[] args){

    }

}
