import java.util.Iterator;


public class AvlTree implements Iterable<Integer> {

    private final static int NEGATIVE_CONTAINS_RESULT = -1;

    protected AvlNode root;

    /**
     * The default constructor for the AvlTree class
     */
    public AvlTree(){

    }

    /**
     * A constructor that takes an array of integers and initializes a new AvlTree containing the elements in
     * the array
     * @param data An array of integers to be added to the AVL Tree
     */
    public AvlTree(int[] data){
        if(data != null) {
            for (int newValue : data) {
                add(newValue);
            }
        }
    }

    /**
     * A constructor that takes an existing AvlTree and creates a deep copy in a new AvlTree
     * @param tree the AvlTree to be deep-copied
     */
    public AvlTree(AvlTree tree){

    }

    /**
     * Take an integer and add it to the Avl tree
     * @param newValue the integer value to be added
     * @return True if the value was added successfully, false otherwise
     */
    public boolean add(int newValue){
        if(contains(newValue) != NEGATIVE_CONTAINS_RESULT) {
            AvlNode addedNode = addNode(root, newValue);
            rebalanceNode(addedNode);
            return true;
        }
        else{
            return false;
        }
    }

    private AvlNode addNode(AvlNode node, int addValue){
        if(node == null){
            node = new AvlNode();
            node.setData(addValue);
            return node;
        }
        else if(node.getData() > addValue){
            return(addNode(node.getRightChild(), addValue));
        }
        else{
            return(addNode(node.getLeftChild(), addValue));
        }
    }

    private void rebalanceNode(AvlNode node){
        int balance = node.findNodeBalance();
        if(balance > 1){
            if(){

            }
            else if(){

            }
        }
        else if(balance < -1){
            if(){

            }
            else if(){
                
            }
        }
        if(node.getParent() != null){
            rebalanceNode(node.getParent());
        }
    }


    /**
     * Take an integer and search the Avl tree to see if the integer is contained in the tree
     * @param searchVal the integer value to be searched for
     * @return The depth of the element in the tree if the tree contains the value, -1 otherwise
     */
    public int contains(int searchVal){
        return containsHelper(root, searchVal);
    }

    /**
     *
     * @param root
     * @param searchVal
     * @return
     */
    private int containsHelper(AvlNode node, int searchVal) {
        if (node.getData() == searchVal) {
            return node.getNodeDepth();
        } else if (node.getRightChild() == null && node.getLeftChild() == null) {
            return NEGATIVE_CONTAINS_RESULT;
        } else {
            if (node.getRightChild() != null && containsHelper(node.getRightChild(), searchVal) !=
                    NEGATIVE_CONTAINS_RESULT) {
                return containsHelper(node.getRightChild(), searchVal);
            }
            if (node.getLeftChild() != null && containsHelper(node.getLeftChild(), searchVal) !=
                    NEGATIVE_CONTAINS_RESULT) {
                return containsHelper(node.getLeftChild(), searchVal);
            }
        }
        return NEGATIVE_CONTAINS_RESULT;
    }

    /**
     * Take an integer and attempt to delete it from the Avl tree
     * @param toDelete the value to be deleted
     * @return True if the value is found and deleted successfuly, false otherwise.
     */
    public boolean delete(int toDelete){
        return true;
    }


    /**
     * Returns the current number of nodes in the Avl tree
     * @return the current size of the tree
     */
    public int size(){
        return -1;
    }

    /**
     * Returns an Iterator object that iterates over the elements of the Avl tree in ascending order
     * @return An Iterator object that does not implement remove()
     */
    public java.util.Iterator<Integer> iterator(){

    }

    /**
     * Take an integer representing the height of an AvlTree and return the minimum number of nodes
     * possible in an AvlTree of that height.
     * @param h the height of an AvlTree
     * @return the minimum size of an AvlTree
     */
    public static int findMinNodes(int h){
        //Since the minimum size of the avl tree can be expressed as a recursive function, we can use the
        // fibonacci series to find it for height h, using (1 + sqrt(5)/2) as an approximation of the
        // golden ratio
        return (int)(((Math.pow((1 + Math.sqrt(5) / 2), h + 2)-Math.pow((1 - Math.sqrt(5) / 2), h + 2)) /
                Math.sqrt(5)) - 1);
    }

    /**
     * Take an integer representing the height of an AvlTree and return the maximum number of nodes
     * possible in an AvlTree of that height
     * @param h the height of an AvlTree
     * @return the maximum size of an AvlTree
     */
    public static int findMaxNodes(int h){
        return (int)Math.pow(2, h+1) - 1;
    }

    /**
     *
     * @param args
     */

    private void rotateLL(AvlNode root){

    }

    private void rotateLR(AvlNode root){

    }

    private void rotateRR(AvlNode root){

    }

    private void rotateRL(AvlNode root){

    }

    public static void main(java.lang.String[] args){

    }

}
